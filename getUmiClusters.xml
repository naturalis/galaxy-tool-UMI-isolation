<?xml version="1.0" encoding="utf-8"?>
<tool id="getUmiClusters" name="Cluster On UMIs:" version="0.1.0">
    <description>
        Use a python script to cluster all UMIs and output a tabular file, a
        BLAST file and a zip file.
    </description>
    <!-- Call the getUmiClusters script, set input parameters according to user
         choices. -->
    <command interpreter="bash">
        getUmiClusters.sh -o ${fosOutputTabular} -z ${fosOutputZip}
                          -q ${fosBlastFile} -p ${rbProcess}
                          -f ${fisInput.rbSingle} -l ${disUmiLength}
                          -s ${rbSearch} -a ${tfForward} -b ${tfReverse}
        #if $fisInput.rbSingle == "fastq"
            -i $fisInput.fisSingleFastq
        #elif $fisInput.rbSingle == "fasta"
            -i $fisInput.fisSingleFasta
        #end if
    </command>
    <inputs>
        <!-- Catch the input file. -->
        <conditional name="fisInput">
            <param name="rbSingle" type="select" label="FastQ or fastA file."
                   multiple="false">
                <option value="fastq" selected="true">FastQ file</option>
                <option value="fasta">FastA file</option>
            </param>
            <when value="fastq">
                <param name="fisSingleFastq" type="data" format="fastq"
                       label="FastQ file."/>
            </when>
            <when value="fasta">
                <param name="fisSingleFasta" type="data" format="fasta"
                       label="FastA file."/>
            </when>
        </conditional>
        <!-- Catch the search approach. -->
        <param name="rbProcess" type="select"
               label="Primer, scaffold(adapter) or first position?"
               multiple="false">
            <option value="primer" selected="true">Primer search</option>
            <option value="scaffold">Scaffold search</option>
            <option value="zero">First position search</option>
        </param>
        <!-- Catch the number of UMIs per read. -->
        <param name="rbSearch" type="select"
               label="Search UMIs at 5'-end [umi5], 3'-end [umi3] or at 5'-end and 3'-end [umidouble]"
               multiple="false">
            <option value="umi5" selected="true">5'-end UMI</option>
            <option value="umi3">3'-end UMI</option>
            <option value="umidouble">Two end UMIs</option>
        </param>
        <!-- Catch the search nucleotides and length. -->
        <param name="tfForward" size="50" type="text" value="NNNNNNNNNNNNNNN"
               label="The 5'-end search nucleotides"/>
        <param name="tfReverse" size="50" type="text" value="NNNNNNNNNNNNNNN"
               label="The 3'-end search nucleotides"/>
        <param name="disUmiLength" type="integer"
               label="The length of the UMI sequences" value="0" min="0"/>
    </inputs>
    <outputs>
        <!-- Catch the output file. -->
        <data format="tabular" name="fosOutputTabular"
              label="UMI_Accumulation_Table">
        </data>
        <data format="fasta" name="fosBlastFile" label="UMI_Accumulation_BLAST">
        </data>
        <data format="zip" name="fosOutputZip" label="UMI_Accumulation_ZIP">
        </data>
    </outputs>
    <tests>
    </tests>
    <help>
        .. class:: infomark

        Use a python script to accumulate all UMIs and output a tabular file,
        a BLAST file and a zip file. The tabular file will contain all unique
        UMI nucleotides, a count of the number of reads that are associated
        with that umi and a read that represents the sequences associated with
        that umi.

        .. class:: infomark

        The BLAST file can be used to identify all UMI clusters.

        .. class:: infomark

        The zip file will contain fastA files for every unique UMI and contain
        reads associated with that UMI.

        .. class:: warningmark

        Every read in a fastA file should have a header starting with >.
        Every read in a fastQ file should have a header starting with @.
    </help>
</tool>
